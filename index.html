<!-- 
This work is a refusal to be reduced to labels.  
Not a résumé.  
Not a list of jobs.  

Fragments: prompts, songs, symbols.  
Each tap is discovery.  
Each track, a metaphor for skill, experience, or transformation.  

Industrial rhythm — headhunting.      (Front 242)  
Commerce rhythm — persuasion.         (AIJ. Jones)  
Soulful voice — storytelling.         (Tracy Chapman)  
Electronic pulse — technology.        (Kraftwerk)  
Pulse of connection — awareness.      (Stereo MCs)  
Pop anthem — artistry.                (a-ha)  
Voice of inquiry — shards of identity.(Edie Brickell)  
Empowered closure — affirmation.      (Aloe Blacc)  

The music carries the weight of identity.  
The prompts are shards of language, guiding the viewer toward deeper listening, closer looking, and questioning of self.  

Meaning is assembled, not given.  
Connection is felt, not consumed.  

This is not a portfolio.  
It is record and inquiry.  
It is resistance.  
It is stance.  

I am James Tobin.  
-->


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="robots" content="index, follow">

  <!-- SEO Meta Tags -->
  <meta name="description" content="James Tobin’s portfolio refuses to be defined by conventional labels. It is a portrait through fragmented prompts, music, and symbols, exploring the skills, experiences, and roles that shape a professional identity. Each track, each image, is a metaphor for the diverse work and systems that influence identity and career." />
  <meta name="author" content="James Tobin">
  <meta name="keywords" content="James Tobin, portfolio, professional identity, career, work, interactive design, multimedia, music, narrative, professional roles, skills, identity fragments">

  <!-- Open Graph Meta Tags (for social media sharing) -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="James Tobin">
  <meta property="og:description" content="James Tobin’s portfolio refuses to be defined by conventional labels. It is a portrait through fragmented prompts, music, and symbols, exploring the skills, experiences, and roles that shape a professional identity. Each track, each image, is a metaphor for the diverse work and systems that influence identity and career.">
  <meta property="og:url" content="https://www.jamestobin.xyz">
  <meta property="og:image" content="https://www.jamestobin.xyz/favicon.jpg">

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="James Tobin">
  <meta name="twitter:description" content="James Tobin’s portfolio refuses to be defined by conventional labels. It is a portrait through fragmented prompts, music, and symbols, exploring the skills, experiences, and roles that shape a professional identity. Each track, each image, is a metaphor for the diverse work and systems that influence identity and career.">
  <meta name="twitter:image" content="https://www.jamestobin.xyz/favicon.jpg">

  <!-- iPhone Home Screen -->
<link rel="apple-touch-icon" sizes="180x180" href="https://www.jamestobin.xyz/favicon.jpg">

<!-- Optional for older iPads / iPhone sizes -->
<link rel="apple-touch-icon" sizes="152x152" href="https://www.jamestobin.xyz/favicon.jpg">
<link rel="apple-touch-icon" sizes="120x120" href="https://www.jamestobin.xyz/favicon.jpg">
<link rel="apple-touch-icon" sizes="76x76" href="https://www.jamestobin.xyz/favicon.jpg">
  
  <title>James Tobin</title>

  </head>

<style>
:root {
  --bg: #000;
  --accent: #c4002f;
  --text: #f2f2f2;
}
* { box-sizing: border-box; }
html, body {
  height: 100%;
  margin: 0;
  background: var(--bg);
  overflow: hidden;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  color: var(--text);
  
}


.stage {
  position: relative;
  width: 100vw;
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: black;
}

.barrel {
  animation: gentlePulse 4s ease-in-out infinite;
  position: absolute;
  width: 70vmin;
  height: 70vmin;
  max-width: 680px;
  max-height: 680px;
  border-radius: 50%;
  overflow: hidden;
  cursor: grab;
  box-shadow: 0 0 40px rgba(255, 255, 255, 0.12);
  z-index: 3;
  touch-action: none;
  -webkit-user-drag: none;
  user-select: none;
  -webkit-user-select: none;
  will-change: transform;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
}

.barrel:hover {
  box-shadow: 0 0 80px rgba(196, 0, 47, 0.8), 0 0 150px rgba(196, 0, 47, 0.4);
  transition: box-shadow 0.3s ease-in-out; /* Smooth transition for lighting */
}


.barrel.dragging-volume {
  box-shadow: 0 0 0px rgba(0, 0, 0, 0.0), 0 0 0px rgba(0, 0, 0, 0);
  animation: none;
}


.barrel.pulse {
  animation: pulseCircle 2s ease-in-out infinite;
}

.barrel.dragging-position {
  cursor: grabbing;
}


.barrel:not(.dragging-volume):not(:hover) {
  box-shadow: 0 0 40px rgba(255, 255, 255, 0.12);
}


@keyframes gentlePulse {
  0%, 100% { box-shadow: 0 0 30px rgba(196, 0, 47, 0.3); }
  50% { box-shadow: 0 0 50px rgba(196, 0, 47, 0.5); }
}

@keyframes pulseCircle {
  0%, 100% { 
    transform: scale(1); 
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
  }
  50% { 
    transform: scale(1.03); 
    box-shadow: 0 0 30px rgba(196, 0, 47, 0.6);
  }
}

.outer-ring {
  position: absolute;
  inset: 0;
  border-radius: 50%;
  pointer-events: none;
  transition: box-shadow 0.15s ease;
  z-index: 1;
}

.outer-ring.active {
  box-shadow: inset 0 0 40px rgba(196, 0, 47, 0.6), inset 0 0 80px rgba(196, 0, 47, 0.3);
}

.aperture {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 60%;
  height: 60%;
  border-radius: 50%;
  background: black;
  box-shadow: inset 0 0 80px #000;
  z-index: 2;
  overflow: hidden;
}

canvas#starfield {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  display: none;
  z-index: 5;
}

#coverImage {
  position: absolute;
  pointer-events: none;
  -webkit-user-drag: none;
  user-drag: none;
  -webkit-user-select: none;
  user-select: none;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 50%;
  display: none;
  z-index: 20;
}

.cover-spin {
  animation: spin 6s linear infinite;
  transform-origin: 50% 50%;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.spin-hint {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #d9d9d9;
  font-size: 2vmin;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  opacity: 0.65;
  pointer-events: none;
  animation: pulse 1.6s ease-in-out infinite;
  z-index: 10;
  white-space: nowrap;
  max-width: 90%;
  text-align: center;
}

.spin-hint.hidden { display: none !important; }

@keyframes pulse { 
  0%,100%{opacity:0.4}
  50%{opacity:0.9} 
}

.center-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #fff;
  white-space: nowrap;
  font-size: 2.6vmin;
  text-align: center;
  z-index: 21;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

.center-text.show { opacity: 1; }

.volume-indicator {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.85);
  color: #fff;
  font-weight: bold;
  font-size: 2rem;
  padding: 12px 24px;
  border-radius: 12px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.1s;
  z-index: 7;
}

.volume-indicator.show { opacity: 1; }

#jamesImage {
  position: absolute;
  pointer-events: none;
  -webkit-user-drag: none;
  user-drag: none;
  -webkit-user-select: none;
  user-select: none;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: none;
  z-index: 6;
}
</style>
</head>
<body id="artifacts-component-root-html">

<div class="stage">
  <div class="barrel pulse" id="barrel">
    <div class="outer-ring" id="outerRing"></div>
    <div class="aperture" id="aperture">
      <canvas id="starfield"></canvas>
      <img id="jamesImage" src="images/jamestobin_2.png" alt="James Tobin" />
      <img id="coverImage" src="" alt="Cover" />
      <div id="centerText" class="center-text"></div>
      <div id="volumeIndicator" class="volume-indicator">Volume: 25%</div>
    </div>
    <div class="spin-hint" id="spinHint">Tap | Touch</div>
  </div>
</div>

<script>
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const gainNode = audioCtx.createGain();
gainNode.gain.value = 0.25;
gainNode.connect(audioCtx.destination);

const sharedAudio = new Audio();
const sharedSource = audioCtx.createMediaElementSource(sharedAudio);
sharedSource.connect(gainNode);

let onTrackEnded = null;
sharedAudio.onended = () => {
  if (onTrackEnded) onTrackEnded();
};

function playThroughGain(src) {
  sharedAudio.pause();
  sharedAudio.src = src;
  sharedAudio.load();
  sharedAudio.play().catch(() => {});
}

function unlockAudio() {
  const silent = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YQAAAAA=');
  silent.play().catch(() => {});
}
window.addEventListener('touchstart', unlockAudio, { once: true });
window.addEventListener('click', unlockAudio, { once: true });

const messages = [
  { line: " ", music: "media/intro.mp3", cover: "favicon.jpg", caption: "" },
  { line: " ", music: "media/slide1-reduced.mp3", cover: "images/cover1.png", caption: "Industrial rhythms — metaphor for headhunting and the machinery of recruitment." },
  { line: " ", music: "media/slide_new1.mp3", cover: "images/cover_new1.png", caption: "Commerce rhythm — persuasion." },
  { line: " ", music: "media/slide3-reduced.mp3", cover: "images/cover2.png", caption: "Soulful storytelling — communication expressed through voice, narrative, and empathy." },
  { line: " ", music: "media/slide2-reduced.mp3", cover: "images/cover3.png", caption: "Electronic pulse — technology." },
  { line: " ", music: "media/slide4-reduced.mp3", cover: "images/cover4.png", caption: "Pulse of connection — awareness." },
  { line: " ", music: "media/slide5-reduced.mp3", cover: "images/cover5.png", caption: "Pop anthem — artistry." },
  { line: " ", music: "media/slide6-reduced.mp3", cover: "images/cover6.png", caption: "Voice of inquiry — shards of identity." },
  { line: "I'm James Tobin.", music: "media/slide7.mp3", caption: "Empowered closure — affirmation." }
];

const hints = [
  "Tap", "Tap (›)", "Clues? (›)", "Story? (›)", "Threads (›)",
  "Listen? (›)", "Look (›)", "Shards? (›)", "Who? (›)", " "
];

let idx = -1;
let firstClickShown = false;
let dragging = false;
let draggingPosition = false;
let dragStartX = 0;
let dragStartY = 0;
let barrelX = 0;
let barrelY = 0;
let manuallyPositioned = false;

const barrel = document.getElementById("barrel");
const outerRing = document.getElementById("outerRing");
const spinHint = document.getElementById("spinHint");
const aperture = document.getElementById("aperture");
const starCanvas = document.getElementById("starfield");
const ctx = starCanvas.getContext("2d");
const centerText = document.getElementById("centerText");
const james = document.getElementById("jamesImage");
const coverImage = document.getElementById("coverImage");
const volumeIndicator = document.getElementById("volumeIndicator");

let stars = [];
let animationFrameId;
let lastFrameTime = 0;
const FRAME_INTERVAL = 1000 / 30;

function resizeCanvas() {
  starCanvas.width = aperture.offsetWidth;
  starCanvas.height = aperture.offsetHeight;
}

function createStars(count = 100) {
  stars = [];
  for (let i = 0; i < count; i++) {
    stars.push({
      x: Math.random() * starCanvas.width,
      y: Math.random() * starCanvas.height,
      r: Math.random() * 2 + 0.5,
      vx: (Math.random() - 0.5) * 1.2,
      vy: (Math.random() - 0.5) * 1.2,
      alpha: Math.random() * 0.7 + 0.3,
      color: `hsl(${Math.random() * 10 + 350}, 100%, 80%)`
    });
  }
}

function drawStars(timestamp) {
  if (timestamp - lastFrameTime < FRAME_INTERVAL) {
    animationFrameId = requestAnimationFrame(drawStars);
    return;
  }
  lastFrameTime = timestamp;

  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, starCanvas.width, starCanvas.height);

  for (let s of stars) {
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fillStyle = s.color;
    ctx.globalAlpha = s.alpha;
    ctx.fill();

    s.x += s.vx;
    s.y += s.vy;

    if (s.x < 0) s.x = starCanvas.width;
    if (s.x > starCanvas.width) s.x = 0;
    if (s.y < 0) s.y = starCanvas.height;
    if (s.y > starCanvas.height) s.y = 0;
  }

  ctx.globalAlpha = 1;
  animationFrameId = requestAnimationFrame(drawStars);
}

function startStarfield() {
  resizeCanvas();
  createStars();
  starCanvas.style.display = "block";
  animationFrameId = requestAnimationFrame(drawStars);
}

function stopStarfield() {
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
  }
  starCanvas.style.display = "none";
}

const barrelElement = document.querySelector('.barrel'); // Update selector accordingly

const volumeSliderContainer = document.createElement('div');
const volumeSlider = document.createElement('input');
const volumeFill = document.createElement('div');
const volumeLabel = document.createElement('div');

Object.assign(volumeSliderContainer.style, {
  position: "absolute",
  top: "20px",
  left: "20px",
  width: "calc(100% - 40px)",
  display: "flex",
  alignItems: "center",
  gap: "10px",
  zIndex: "1000"
});

volumeLabel.textContent = "VOLUME";
Object.assign(volumeLabel.style, {
  color: "#c4002f",
  fontSize: "14px",
  fontWeight: "600",
  textTransform: "uppercase",
  letterSpacing: "0.05em",
  minWidth: "70px",
  opacity: "0.9",
  flexShrink: "0"
});

const volumeBarWrapper = document.createElement('div');
Object.assign(volumeBarWrapper.style, {
  position: "relative",
  flex: "1",
  height: "8px",
  backgroundColor: "rgba(255, 255, 255, 0.2)",
  borderRadius: "4px"
});

Object.assign(volumeFill.style, {
  position: "absolute",
  height: "100%",
  backgroundColor: "#c4002f",
  width: "25%",
  pointerEvents: "none",
  transition: "width 0.05s linear",
  borderRadius: "4px"
});

volumeSlider.type = "range";
volumeSlider.min = "0";
volumeSlider.max = "100";
volumeSlider.value = "25";
Object.assign(volumeSlider.style, {
  position: "absolute",
  top: "0",
  left: "0",
  width: "100%",
  height: "100%",
  cursor: "pointer",
  opacity: "0",
  zIndex: "2"
});

volumeBarWrapper.appendChild(volumeFill);
volumeBarWrapper.appendChild(volumeSlider);
volumeSliderContainer.appendChild(volumeLabel);
volumeSliderContainer.appendChild(volumeBarWrapper);
document.body.appendChild(volumeSliderContainer);

volumeSlider.addEventListener('input', (e) => {
  const v = e.target.value / 100;
  gainNode.gain.value = v;
  volumeFill.style.width = `${e.target.value}%`;
  
  volumeIndicator.textContent = `Volume: ${e.target.value}%`;
  volumeIndicator.classList.add("show");
  
  clearTimeout(window.volumeIndicatorTimeout);
  window.volumeIndicatorTimeout = setTimeout(() => {
    volumeIndicator.classList.remove("show");
  }, 1000);
});

const progressBarContainer = document.createElement('div');
const progressBar = document.createElement('div');
const progressInput = document.createElement('input');
const progressLabel = document.createElement('div');

Object.assign(progressBarContainer.style, {
  position: "absolute",
  bottom: "20px",
  left: "20px",
  width: "calc(100% - 40px)",
  display: "flex",
  alignItems: "center",
  gap: "10px",
  zIndex: "1000"
});

progressLabel.textContent = "NAVIGATE";
Object.assign(progressLabel.style, {
  color: "#fff",
  fontSize: "14px",
  fontWeight: "600",
  textTransform: "uppercase",
  letterSpacing: "0.05em",
  minWidth: "80px",
  opacity: "0.9",
  flexShrink: "0"
});

const progressBarInner = document.createElement('div');
Object.assign(progressBarInner.style, {
  position: "relative",
  flex: "1",
  height: "8px",
  backgroundColor: "rgba(255, 255, 255, 0.2)",
  borderRadius: "4px",
  overflow: "hidden"
});

Object.assign(progressBar.style, {
  height: "100%",
  backgroundColor: "white",
  width: "0%",
  pointerEvents: "none",
  transition: "width 0.2s ease"
});

progressInput.type = "range";
progressInput.min = "0";
progressInput.max = String(messages.length - 1);
progressInput.value = "0";
Object.assign(progressInput.style, {
  position: "absolute",
  top: "0",
  left: "0",
  width: "100%",
  height: "100%",
  cursor: "pointer",
  opacity: "0",
  zIndex: "2"
});

progressBarInner.appendChild(progressBar);
progressBarInner.appendChild(progressInput);
progressBarContainer.appendChild(progressLabel);
progressBarContainer.appendChild(progressBarInner);
document.body.appendChild(progressBarContainer);

let currentShowCover = null;
let currentHideCover = null;

progressInput.addEventListener('input', (e) => {
  const newIdx = parseInt(e.target.value);
  
  if (!barrel.classList.contains("playing")) return;
  
  sharedAudio.pause();
  sharedAudio.currentTime = 0;
  
  if (currentShowCover) {
    aperture.removeEventListener("mouseenter", currentShowCover);
    aperture.removeEventListener("touchstart", currentShowCover);
  }
  if (currentHideCover) {
    aperture.removeEventListener("mouseleave", currentHideCover);
    aperture.removeEventListener("touchend", currentHideCover);
  }
  currentShowCover = null;
  currentHideCover = null;
  
  idx = newIdx;
  stopStarfield();
  james.style.display = "none";
  coverImage.style.display = "none";
  centerText.classList.remove("show");
  barrel.classList.remove("playing");
  barrel.classList.add("pulse");
  spinHint.classList.remove("hidden");
  
  spinHint.textContent = hints[idx] || "Tap (›)";
  
  progressBar.style.width = `${((idx + 1) / messages.length) * 100}%`;
  progressInput.value = idx;
});

function resetToFirstSlide() {
  idx = -1;
  stopStarfield();
  james.style.display = "none";
  coverImage.style.display = "none";
  centerText.classList.remove("show");
  centerText.textContent = "";
  spinHint.textContent = "Tap | Touch";
  spinHint.classList.remove("hidden");
  barrel.classList.remove("playing");
  barrel.classList.add("pulse");
  
  sharedAudio.pause();
  sharedAudio.currentTime = 0;
  
  centerText.removeEventListener("click", resetToFirstSlide);
  coverImage.classList.remove("cover-spin");
  progressBar.style.width = "0%";
  progressInput.value = 0;
}

function showMessage(i) {
  const m = messages[i];
  
  stopStarfield();
  james.style.display = "none";
  coverImage.style.display = "none";
  centerText.classList.remove("show");
  centerText.textContent = "";
  spinHint.classList.add("hidden");
  barrel.classList.remove("pulse");
  barrel.classList.add("playing");

  playThroughGain(m.music);
  
  const showCover = () => {
    if (m.cover) {
      coverImage.src = m.cover;
      coverImage.style.display = "block";
      coverImage.classList.add("cover-spin");
    }
    if (m.line) {
      centerText.textContent = m.line;
      centerText.classList.add("show");
    }
  };
  
  const hideCover = () => {
    coverImage.style.display = "none";
    coverImage.classList.remove("cover-spin");
    centerText.classList.remove("show");
  };
  
  if (currentShowCover) {
    aperture.removeEventListener("mouseenter", currentShowCover);
    aperture.removeEventListener("touchstart", currentShowCover);
  }
  if (currentHideCover) {
    aperture.removeEventListener("mouseleave", currentHideCover);
    aperture.removeEventListener("touchend", currentHideCover);
  }
  
  currentShowCover = showCover;
  currentHideCover = hideCover;
  
  if (i !== messages.length - 1) {
    startStarfield();
    
    aperture.addEventListener("mouseenter", showCover);
    aperture.addEventListener("mouseleave", hideCover);
    aperture.addEventListener("touchstart", showCover);
    aperture.addEventListener("touchend", hideCover);
  }

  onTrackEnded = () => {
    if (idx === messages.length - 1) {
      resetToFirstSlide();
      return;
    }

    stopStarfield();
    coverImage.style.display = "none";
    coverImage.classList.remove("cover-spin");
    centerText.classList.remove("show");
    barrel.classList.remove("playing");
    spinHint.classList.remove("hidden");
    spinHint.textContent = "Tap (›)";
    
    aperture.removeEventListener("mouseenter", showCover);
    aperture.removeEventListener("mouseleave", hideCover);
    aperture.removeEventListener("touchstart", showCover);
    aperture.removeEventListener("touchend", hideCover);
    
    currentShowCover = null;
    currentHideCover = null;
  };

  if (i === messages.length - 1) {
    stopStarfield();
    coverImage.style.display = "none";
    james.style.display = "block";

    setTimeout(() => {
      centerText.textContent = "I'm James Tobin.";
      centerText.classList.add("show");
      centerText.addEventListener("click", resetToFirstSlide, { once: true });
    }, 2000);
  }

  progressBar.style.width = `${((i + 1) / messages.length) * 100}%`;
  progressInput.value = i;
}

barrel.addEventListener("click", (e) => {
  if (dragging || draggingPosition) return;
  if (barrel.classList.contains("playing")) return;

  audioCtx.resume();

  if (!firstClickShown) {
    firstClickShown = true;
    spinHint.textContent = "Play Audio? (›)";
    
    spinHint.onclick = () => {
      spinHint.classList.add("hidden");
      idx = 0;
      showMessage(idx);
    };
    return;
  }

  idx++;
  if (idx < messages.length) {
    showMessage(idx);
  }
});

function getVolume(e) {
  const rect = barrel.getBoundingClientRect();
  const cy = rect.top + rect.height / 2;
  const radius = rect.height / 2;
  const y = e.touches ? e.touches[0].clientY : e.clientY;
  const v = (cy - y + radius) / (2 * radius);
  return Math.min(Math.max(v, 0), 1);
}

let dragTimeout;

barrel.addEventListener("mousedown", (e) => {
  const startTime = Date.now();
  const startX = e.clientX;
  const startY = e.clientY;
  
  const checkDrag = () => {
    const timeDiff = Date.now() - startTime;
    const distance = Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2));
    
    if (timeDiff > 150 && barrel.classList.contains("playing")) {
      dragging = true;
      volumeIndicator.classList.add("show");
    } else if (distance > 10) {
      draggingPosition = true;
      barrel.classList.add("dragging-position");
      dragStartX = e.clientX - barrelX;
      dragStartY = e.clientY - barrelY;
    }
  };
  
  dragTimeout = setTimeout(checkDrag, 150);
  
  const moveHandler = (moveE) => {
    const distance = Math.sqrt(Math.pow(moveE.clientX - startX, 2) + Math.pow(moveE.clientY - startY, 2));
    if (distance > 10) {
      clearTimeout(dragTimeout);
      draggingPosition = true;
      barrel.classList.add("dragging-position");
      dragStartX = moveE.clientX - barrelX;
      dragStartY = moveE.clientY - barrelY;
      window.removeEventListener("mousemove", moveHandler);
    }
  };
  
  window.addEventListener("mousemove", moveHandler);
  setTimeout(() => window.removeEventListener("mousemove", moveHandler), 200);
});

barrel.addEventListener("touchstart", (e) => {
  const startTime = Date.now();
  const touch = e.touches[0];
  const startX = touch.clientX;
  const startY = touch.clientY;
  
  const checkDrag = () => {
    const timeDiff = Date.now() - startTime;
    
    if (timeDiff > 150 && barrel.classList.contains("playing")) {
      dragging = true;
      volumeIndicator.classList.add("show");
    }
  };
  
  dragTimeout = setTimeout(checkDrag, 150);
  
  const moveHandler = (moveE) => {
    const touch = moveE.touches[0];
    const distance = Math.sqrt(Math.pow(touch.clientX - startX, 2) + Math.pow(touch.clientY - startY, 2));
    if (distance > 10) {
      clearTimeout(dragTimeout);
      draggingPosition = true;
      barrel.classList.add("dragging-position");
      dragStartX = touch.clientX - barrelX;
      dragStartY = touch.clientY - barrelY;
      window.removeEventListener("touchmove", moveHandler);
    }
  };
  
  window.addEventListener("touchmove", moveHandler, { passive: true });
  setTimeout(() => window.removeEventListener("touchmove", moveHandler), 200);
}, { passive: true });

window.addEventListener("mousemove", (e) => {
  if (draggingPosition) {
    barrelX = e.clientX - dragStartX;
    barrelY = e.clientY - dragStartY;
    barrel.style.left = `${barrelX}px`;
    barrel.style.top = `${barrelY}px`;
  } else if (dragging) {
    const v = getVolume(e);
    gainNode.gain.value = v;
    volumeIndicator.textContent = `Volume: ${Math.round(v * 100)}%`;
    
    volumeSlider.value = Math.round(v * 100);
    volumeFill.style.width = `${Math.round(v * 100)}%`;
    
    barrel.classList.add("dragging-volume");
    outerRing.classList.add("active");
  }
});

window.addEventListener("touchmove", (e) => {
  if (draggingPosition) {
    e.preventDefault();
    const touch = e.touches[0];
    barrelX = touch.clientX - dragStartX;
    barrelY = touch.clientY - dragStartY;
    barrel.style.left = `${barrelX}px`;
    barrel.style.top = `${barrelY}px`;
  } else if (dragging) {
    e.preventDefault();
    const v = getVolume(e);
    gainNode.gain.value = v;
    volumeIndicator.textContent = `Volume: ${Math.round(v * 100)}%`;
    
    volumeSlider.value = Math.round(v * 100);
    volumeFill.style.width = `${Math.round(v * 100)}%`;
    
    barrel.classList.add("dragging-volume");
    outerRing.classList.add("active");
  }
}, { passive: false });

function stopDrag() {
  clearTimeout(dragTimeout);
  
  if (dragging) {
    // Remove classes immediately for visual feedback
    barrel.classList.remove("dragging-volume");
    outerRing.classList.remove("active");
    
    // Reset dragging state after a short delay to prevent click events
    setTimeout(() => { 
      dragging = false; 
    }, 100);
  }
  
  if (draggingPosition) {
    manuallyPositioned = true;
    barrel.classList.remove("dragging-position");
    setTimeout(() => { 
      draggingPosition = false; 
    }, 100);
  }
  
  // Hide volume indicator with slight delay for better UX
  setTimeout(() => {
    volumeIndicator.classList.remove("show");
  }, 500);
}

window.addEventListener("mouseup", stopDrag);
window.addEventListener("touchend", stopDrag);

function scaleUI() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  
  const barrelRect = barrel.getBoundingClientRect();
  const barrelSize = barrelRect.width;
  
  if (!manuallyPositioned) {
    barrelX = (vw - barrelSize) / 2;
    barrelY = (vh - barrelSize) / 2;
  }
  
  barrel.style.left = `${barrelX}px`;
  barrel.style.top = `${barrelY}px`;
  
  if (starCanvas.style.display === "block") {
    resizeCanvas();
  }
}

let resizeTimeout;
function handleResize() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(scaleUI, 100);
}

window.addEventListener('load', scaleUI);
window.addEventListener('resize', handleResize);
window.addEventListener('orientationchange', () => {
  setTimeout(scaleUI, 300);
});
</script>

<script>
(function() {
  const dynamicStyle = document.createElement('style');
  dynamicStyle.setAttribute('id', 'dynamic-highres-style');
  document.head.appendChild(dynamicStyle);

  function applyHighResSizing() {
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const dpr = window.devicePixelRatio || 1;

    // Detect orientation
    const isPortrait = vh > vw;

    // Base barrel size: use width in portrait, vmin in landscape
    let barrelSize = isPortrait ? 0.70 * vw : 0.70 * Math.min(vw, vh);

    // Gentle boost for large screens
    if (vw >= 2560) barrelSize *= 1.05;
    if (vw >= 3840) barrelSize *= 1.15;
    if (vw >= 5120) barrelSize *= 1.25;
    if (dpr >= 2)   barrelSize *= 1.05;

    // Small device shrink
    if (vw <= 480) barrelSize *= 0.85;

    // Clamp between 200px (phones) and 1200px (big monitors)
    barrelSize = Math.max(200, Math.min(barrelSize, 1200));

    // Font scaling
    let rootFont = 16;
    if (vw >= 2560) rootFont = 17;
    if (vw >= 3840) rootFont = 19;
    if (vw >= 5120) rootFont = 21;
    if (dpr >= 2)   rootFont += 1;
    if (vw <= 480)  rootFont = 14;
    rootFont = Math.min(rootFont, 22);

    // Text sizes
    const hintFontPx   = vw <= 480 ? 12 : Math.round((2.0 / 100) * (isPortrait ? vw : Math.min(vw, vh)));
    const centerFontPx = vw <= 480 ? 14 : Math.round((2.6 / 100) * (isPortrait ? vw : Math.min(vw, vh)));
    const volFontPx    = Math.round(rootFont * 1.3);

    dynamicStyle.textContent = `
      html { font-size: ${rootFont}px; }
      .barrel {
        width: ${barrelSize}px !important;
        height: ${barrelSize}px !important;
        max-width: none !important;
        max-height: none !important;
      }
      .aperture { width: 60% !important; height: 60% !important; }
      .spin-hint { font-size: ${hintFontPx}px !important; }
      .center-text { font-size: ${centerFontPx}px !important; }
      .volume-indicator { font-size: ${volFontPx}px !important; }
      body > div[style*="width: calc(100% - 40px)"][style*="display: flex"] div[style*="height: 8px"] {
        height: ${vw <= 480 ? 6 : 10}px !important;
      }
    `;

    // Re-center barrel
    const barrel = document.getElementById('barrel');
    if (barrel) {
      const rect = barrel.getBoundingClientRect();
      barrel.style.left = `${(vw - rect.width) / 2}px`;
      barrel.style.top  = `${(vh - rect.height) / 2}px`;
    }

    // Resize starfield canvas if visible
    const starCanvas = document.getElementById('starfield');
    const aperture = document.getElementById('aperture');
    if (starCanvas && aperture && starCanvas.style.display === 'block') {
      starCanvas.width  = aperture.offsetWidth;
      starCanvas.height = aperture.offsetHeight;
    }
  }

  window.addEventListener('load', applyHighResSizing);
  window.addEventListener('resize', applyHighResSizing);
  window.addEventListener('orientationchange', () => setTimeout(applyHighResSizing, 200));
})();
</script>

</body>
</html>


