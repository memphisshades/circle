<!-- 
This work is a refusal to be reduced to labels.  
Not a rÃ©sumÃ©.  
Not a list of jobs.  

Fragments: prompts, songs, symbols.  
Each tap is discovery.  
Each track, a metaphor for skill, experience, or transformation.  

Industrial rhythm â€” headhunting.      (Front 242)  
Commerce rhythm â€” persuasion.         (AIJ. Jones)  
Soulful voice â€” storytelling.         (Tracy Chapman)  
Electronic pulse â€” technology.        (Kraftwerk)  
Pulse of connection â€” awareness.      (Stereo MCs)  
Pop anthem â€” artistry.                (a-ha)  
Voice of inquiry â€” shards of identity.(Edie Brickell)  
Empowered closure â€” affirmation.      (Aloe Blacc)  

The music carries the weight of identity.  
The prompts are shards of language, guiding the viewer toward deeper listening, closer looking, and questioning of self.  

Meaning is assembled, not given.  
Connection is felt, not consumed.  

This is not a portfolio.  
It is record and inquiry.  
It is resistance.  
It is stance.  

I am James Tobin.  
-->


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="robots" content="index, follow">

  <!-- SEO Meta Tags -->
  <meta name="description" content="James Tobinâ€™s portfolio refuses to be defined by conventional labels. It is a portrait through fragmented prompts, music, and symbols, exploring the skills, experiences, and roles that shape a professional identity. Each track, each image, is a metaphor for the diverse work and systems that influence identity and career." />
  <meta name="author" content="James Tobin">
  <meta name="keywords" content="James Tobin, portfolio, professional identity, career, work, interactive design, multimedia, music, narrative, professional roles, skills, identity fragments">

  <!-- Open Graph Meta Tags (for social media sharing) -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="James Tobin">
  <meta property="og:description" content="James Tobinâ€™s portfolio refuses to be defined by conventional labels. It is a portrait through fragmented prompts, music, and symbols, exploring the skills, experiences, and roles that shape a professional identity. Each track, each image, is a metaphor for the diverse work and systems that influence identity and career.">
  <meta property="og:url" content="https://www.jamestobin.xyz">
  <meta property="og:image" content="https://www.jamestobin.xyz/favicon.jpg">

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="James Tobin">
  <meta name="twitter:description" content="James Tobinâ€™s portfolio refuses to be defined by conventional labels. It is a portrait through fragmented prompts, music, and symbols, exploring the skills, experiences, and roles that shape a professional identity. Each track, each image, is a metaphor for the diverse work and systems that influence identity and career.">
  <meta name="twitter:image" content="https://www.jamestobin.xyz/favicon.jpg">

  <!-- iPhone Home Screen -->
<link rel="apple-touch-icon" sizes="180x180" href="https://www.jamestobin.xyz/favicon.jpg">

<!-- Optional for older iPads / iPhone sizes -->
<link rel="apple-touch-icon" sizes="152x152" href="https://www.jamestobin.xyz/favicon.jpg">
<link rel="apple-touch-icon" sizes="120x120" href="https://www.jamestobin.xyz/favicon.jpg">
<link rel="apple-touch-icon" sizes="76x76" href="https://www.jamestobin.xyz/favicon.jpg">
  
  <title>James Tobin</title>

  </head>

<style>
:root {
  --bg: #000;
  --accent: #c4002f;
  --text: #f2f2f2;
}
* { box-sizing: border-box; }
html, body {
  height: 100%;
  margin: 0;
  background: var(--bg);
  overflow: hidden;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  color: var(--text);
  
}


.stage {
  position: relative;
  width: 100vw;
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: black;
}

.barrel {
  animation: gentlePulse 4s ease-in-out infinite;
  position: absolute;
  width: 70vmin;
  height: 70vmin;
  max-width: 680px;
  max-height: 680px;
  border-radius: 50%;
  overflow: hidden;
  cursor: grab;
  box-shadow: 0 0 40px rgba(255, 255, 255, 0.12);
  z-index: 3;
  touch-action: none;
  -webkit-user-drag: none;
  user-select: none;
  -webkit-user-select: none;
  will-change: transform;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
}

.barrel:hover {
  box-shadow: 0 0 80px rgba(196, 0, 47, 0.8), 0 0 150px rgba(196, 0, 47, 0.4);
  transition: box-shadow 0.3s ease-in-out; /* Smooth transition for lighting */
}


.barrel.dragging-volume {
  box-shadow: 0 0 0px rgba(0, 0, 0, 0.0), 0 0 0px rgba(0, 0, 0, 0);
  animation: none;
}


.barrel.pulse {
  animation: pulseCircle 2s ease-in-out infinite;
}

.barrel.dragging-position {
  cursor: grabbing;
}


.barrel:not(.dragging-volume):not(:hover) {
  box-shadow: 0 0 40px rgba(255, 255, 255, 0.12);
}


@keyframes gentlePulse {
  0%, 100% { box-shadow: 0 0 30px rgba(196, 0, 47, 0.3); }
  50% { box-shadow: 0 0 50px rgba(196, 0, 47, 0.5); }
}

@keyframes pulseCircle {
  0%, 100% { 
    transform: scale(1); 
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
  }
  50% { 
    transform: scale(1.03); 
    box-shadow: 0 0 30px rgba(196, 0, 47, 0.6);
  }
}

.outer-ring {
  position: absolute;
  inset: 0;
  border-radius: 50%;
  pointer-events: none;
  transition: box-shadow 0.15s ease;
  z-index: 1;
}

.outer-ring.active {
  box-shadow: inset 0 0 40px rgba(196, 0, 47, 0.6), inset 0 0 80px rgba(196, 0, 47, 0.3);
}

.aperture {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 60%;
  height: 60%;
  border-radius: 50%;
  background: black;
  box-shadow: inset 0 0 80px #000;
  z-index: 2;
  overflow: hidden;
}

canvas#starfield {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  display: none;
  z-index: 5;
}

#coverImage {
  position: absolute;
  pointer-events: none;
  -webkit-user-drag: none;
  user-drag: none;
  -webkit-user-select: none;
  user-select: none;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 50%;
  display: none;
  z-index: 20;
}

.cover-spin {
  animation: spin 6s linear infinite;
  transform-origin: 50% 50%;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.spin-hint {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #d9d9d9;
  font-size: 2vmin;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  opacity: 0.65;
  pointer-events: none;
  animation: pulse 1.6s ease-in-out infinite;
  z-index: 10;
  white-space: nowrap;
  max-width: 90%;
  text-align: center;
}

.spin-hint.hidden { display: none !important; }

@keyframes pulse { 
  0%,100%{opacity:0.4}
  50%{opacity:0.9} 
}

.center-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #fff;
  white-space: nowrap;
  font-size: 2.6vmin;
  text-align: center;
  z-index: 21;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

.center-text.show { opacity: 1; }

.volume-indicator {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.85);
  color: #fff;
  font-weight: bold;
  font-size: 2rem;
  padding: 12px 24px;
  border-radius: 12px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.1s;
  z-index: 7;
}

.volume-indicator.show { opacity: 1; }

#jamesImage {
  position: absolute;
  pointer-events: none;
  -webkit-user-drag: none;
  user-drag: none;
  -webkit-user-select: none;
  user-select: none;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: none;
  z-index: 6;
}
</style>
</head>
<body id="artifacts-component-root-html">

<div class="stage">
  <div class="barrel pulse" id="barrel">
    <div class="outer-ring" id="outerRing"></div>
    <div class="aperture" id="aperture">
      <canvas id="starfield"></canvas>
      <img id="jamesImage" src="images/jamestobin_2.png" alt="James Tobin" />
      <img id="coverImage" src="" alt="Cover" />
      <div id="centerText" class="center-text"></div>
      <div id="volumeIndicator" class="volume-indicator">Volume: 25%</div>
    </div>
    <div class="spin-hint" id="spinHint">Tap | Touch</div>
  </div>
</div>

<script>
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const gainNode = audioCtx.createGain();
gainNode.gain.value = 0; // Start muted
gainNode.connect(audioCtx.destination);

let isMuted = true;
let previousVolume = 0.25;

const sharedAudio = new Audio();
const sharedSource = audioCtx.createMediaElementSource(sharedAudio);
sharedSource.connect(gainNode);

let onTrackEnded = null;
sharedAudio.onended = () => {
  if (onTrackEnded) onTrackEnded();
};

function playThroughGain(src) {
  sharedAudio.pause();
  sharedAudio.src = src;
  sharedAudio.load();
  sharedAudio.play().catch(() => {});
}

function unlockAudio() {
  const silent = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YQAAAAA=');
  silent.play().catch(() => {});
}
window.addEventListener('touchstart', unlockAudio, { once: true });
window.addEventListener('click', unlockAudio, { once: true });

const messages = [
  { line: " ", music: "https://www.jamestobin.xyz/media/intro.mp3", cover: "favicon.jpg", caption: "" },
  { line: " ", music: "https://www.jamestobin.xyz/media/slide1-reduced.mp3", cover: "images/cover1.png", caption: "Industrial rhythms â€” metaphor for headhunting (Front 242)" },
  { line: " ", music: "https://www.jamestobin.xyz/media/slide_new1.mp3", cover: "images/cover_new1.png", caption: "The art of influence and persuasion (AIJ. Jones)" },
  { line: " ", music: "https://www.jamestobin.xyz/media/slide3-reduced.mp3", cover: "images/cover2.png", caption: "Sharing raw emotion and human experience through narrative (Tracy Chapman)" },
  { line: " ", music: "https://www.jamestobin.xyz/media/slide2-reduced.mp3", cover: "images/cover3.png", caption: "Channeling the precision and innovation of creative and digital skills (Kraftwerk)" },
  { line: " ", music: "https://www.jamestobin.xyz/media/slide4-reduced.mp3", cover: "images/cover4.png", caption: "Building tech that connects through voice and entertainment (Stereo MCs)" },
  { line: " ", music: "https://www.jamestobin.xyz/media/slide5-reduced.mp3", cover: "images/cover5.png", caption: "Channeling creativity through visual and digital art. (a-ha)" },
  { line: " ", music: "https://www.jamestobin.xyz/media/slide6-reduced.mp3", cover: "images/cover6.png", caption: "Questioning, discovering, and shaping who I am â€” not defined by just one skill or job (Edie Brickell)" },
  { line: "I'm James Tobin.", music: "https://www.jamestobin.xyz/media/slide7.mp3", caption: "I am James Tobin - empowered affirmation (Aloe Blacc)" }
];

const hints = [
  "Play Audio?", "Tap (â€º)", "Clues? (â€º)", "Story? (â€º)", "Threads (â€º)",
  "Listen? (â€º)", "Look (â€º)", "Shards? (â€º)", "Who? (â€º)", " "
];

let idx = -1;
let firstClickShown = false;
let dragging = false;
let draggingPosition = false;
let dragStartX = 0;
let dragStartY = 0;
let barrelX = 0;
let barrelY = 0;
let manuallyPositioned = false;

const barrel = document.getElementById("barrel");
const outerRing = document.getElementById("outerRing");
const spinHint = document.getElementById("spinHint");
const aperture = document.getElementById("aperture");
const starCanvas = document.getElementById("starfield");
const ctx = starCanvas.getContext("2d");
const centerText = document.getElementById("centerText");
const james = document.getElementById("jamesImage");
const coverImage = document.getElementById("coverImage");
const volumeIndicator = document.getElementById("volumeIndicator");

let stars = [];
let animationFrameId;
let lastFrameTime = 0;
const FRAME_INTERVAL = 1000 / 30;

function resizeCanvas() {
  starCanvas.width = aperture.offsetWidth;
  starCanvas.height = aperture.offsetHeight;
}

function createStars(count = 100) {
  stars = [];
  for (let i = 0; i < count; i++) {
    stars.push({
      x: Math.random() * starCanvas.width,
      y: Math.random() * starCanvas.height,
      r: Math.random() * 2 + 0.5,
      vx: (Math.random() - 0.5) * 1.2,
      vy: (Math.random() - 0.5) * 1.2,
      alpha: Math.random() * 0.7 + 0.3,
      color: `hsl(${Math.random() * 10 + 350}, 100%, 80%)`
    });
  }
}

function drawStars(timestamp) {
  if (timestamp - lastFrameTime < FRAME_INTERVAL) {
    animationFrameId = requestAnimationFrame(drawStars);
    return;
  }
  lastFrameTime = timestamp;

  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, starCanvas.width, starCanvas.height);

  for (let s of stars) {
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fillStyle = s.color;
    ctx.globalAlpha = s.alpha;
    ctx.fill();

    s.x += s.vx;
    s.y += s.vy;

    if (s.x < 0) s.x = starCanvas.width;
    if (s.x > starCanvas.width) s.x = 0;
    if (s.y < 0) s.y = starCanvas.height;
    if (s.y > starCanvas.height) s.y = 0;
  }

  ctx.globalAlpha = 1;
  animationFrameId = requestAnimationFrame(drawStars);
}

function startStarfield() {
  resizeCanvas();
  createStars();
  starCanvas.style.display = "block";
  animationFrameId = requestAnimationFrame(drawStars);
}

function stopStarfield() {
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
  }
  starCanvas.style.display = "none";
}

const barrelElement = document.querySelector('.barrel'); // Update selector accordingly

const volumeSliderContainer = document.createElement('div');
const volumeSlider = document.createElement('input');
const volumeFill = document.createElement('div');
const volumeLabel = document.createElement('div');

Object.assign(volumeSliderContainer.style, {
  position: "absolute",
  top: "20px",
  left: "20px",
  width: "calc(100% - 40px)",
  display: "flex",
  alignItems: "center",
  gap: "10px",
  zIndex: "1000"
});

volumeLabel.textContent = "ðŸ”‡ VOLUME";
Object.assign(volumeLabel.style, {
  color: "#c4002f",
  fontSize: "14px",
  fontWeight: "600",
  textTransform: "uppercase",
  letterSpacing: "0.05em",
  minWidth: "70px",
  opacity: "0.9",
  flexShrink: "0",
  cursor: "pointer",
  transition: "all 0.3s ease",
  userSelect: "none"
});

const volumeBarWrapper = document.createElement('div');
Object.assign(volumeBarWrapper.style, {
  position: "relative",
  flex: "1",
  height: "8px",
  backgroundColor: "rgba(255, 255, 255, 0.2)",
  borderRadius: "4px"
});

Object.assign(volumeFill.style, {
  position: "absolute",
  height: "100%",
  backgroundColor: "#c4002f",
  width: "0%", // Start at 0 for muted state
  pointerEvents: "none",
  transition: "width 0.05s linear",
  borderRadius: "4px"
});

volumeSlider.type = "range";
volumeSlider.min = "0";
volumeSlider.max = "100";
volumeSlider.value = "0"; // Start at 0 for muted state
Object.assign(volumeSlider.style, {
  position: "absolute",
  top: "0",
  left: "0",
  width: "100%",
  height: "100%",
  cursor: "pointer",
  opacity: "0",
  zIndex: "2"
});

volumeBarWrapper.appendChild(volumeFill);
volumeBarWrapper.appendChild(volumeSlider);
volumeSliderContainer.appendChild(volumeLabel);
volumeSliderContainer.appendChild(volumeBarWrapper);
document.body.appendChild(volumeSliderContainer);

// Mute/Unmute toggle functionality
volumeLabel.addEventListener('click', () => {
  if (isMuted) {
    // Unmute
    isMuted = false;
    gainNode.gain.value = previousVolume;
    volumeSlider.value = Math.round(previousVolume * 100);
    volumeFill.style.width = `${Math.round(previousVolume * 100)}%`;
    volumeLabel.textContent = "ðŸ”Š VOLUME";
    
    volumeIndicator.textContent = `Volume: ${Math.round(previousVolume * 100)}%`;
    volumeIndicator.classList.add("show");
    clearTimeout(window.volumeIndicatorTimeout);
    window.volumeIndicatorTimeout = setTimeout(() => {
      volumeIndicator.classList.remove("show");
    }, 1000);
  } else {
    // Mute
    isMuted = true;
    previousVolume = gainNode.gain.value;
    gainNode.gain.value = 0;
    volumeSlider.value = 0;
    volumeFill.style.width = "0%";
    volumeLabel.textContent = "ðŸ”‡ VOLUME";
    
    volumeIndicator.textContent = "Muted";
    volumeIndicator.classList.add("show");
    clearTimeout(window.volumeIndicatorTimeout);
    window.volumeIndicatorTimeout = setTimeout(() => {
      volumeIndicator.classList.remove("show");
    }, 1000);
  }
});

volumeLabel.addEventListener('mouseenter', () => {
  volumeLabel.style.opacity = "1";
  volumeLabel.style.transform = "scale(1.05)";
});

volumeLabel.addEventListener('mouseleave', () => {
  volumeLabel.style.opacity = "0.9";
  volumeLabel.style.transform = "scale(1)";
});

volumeSlider.addEventListener('input', (e) => {
  const v = e.target.value / 100;
  gainNode.gain.value = v;
  volumeFill.style.width = `${e.target.value}%`;
  
  // Update mute state based on slider value
  if (v === 0) {
    isMuted = true;
    volumeLabel.textContent = "ðŸ”‡ VOLUME";
  } else {
    isMuted = false;
    previousVolume = v;
    volumeLabel.textContent = "ðŸ”Š VOLUME";
  }
  
  volumeIndicator.textContent = v === 0 ? "Muted" : `Volume: ${e.target.value}%`;
  volumeIndicator.classList.add("show");
  
  clearTimeout(window.volumeIndicatorTimeout);
  window.volumeIndicatorTimeout = setTimeout(() => {
    volumeIndicator.classList.remove("show");
  }, 1000);
});

const progressBarContainer = document.createElement('div');
const progressBar = document.createElement('div');
const progressInput = document.createElement('input');
const progressLabel = document.createElement('div');


// Create navigation overlay
const navOverlay = document.createElement('div');
Object.assign(navOverlay.style, {
  position: "fixed",
  top: "0",
  left: "0",
  width: "100%",
  height: "100%",
  backgroundColor: "rgba(0, 0, 0, 0.95)",
  zIndex: "9999",
  display: "none",
  overflowY: "auto",
  padding: "40px 20px"
});

const navContent = document.createElement('div');
Object.assign(navContent.style, {
  maxWidth: "800px",
  margin: "0 auto",
  color: "#fff"
});

const navTitle = document.createElement('h2');
navTitle.textContent = "";
Object.assign(navTitle.style, {
  fontSize: "2rem",
  marginBottom: "20px",
  color: "#c4002f",
  textAlign: "center",
  textTransform: "uppercase",
  letterSpacing: "0.1em"
});

const manifestoText = document.createElement('div');
manifestoText.innerHTML = `
  <p style="margin-bottom: 1em;">This work is a refusal to be reduced to labels.<br>
  Not a rÃ©sumÃ©.<br>
  Not a list of jobs.</p>
  
  <p style="margin-bottom: 1em;">Fragments: prompts, songs, symbols.<br>
  Each tap is discovery.<br>
  Each track, a metaphor for skill, experience, or transformation.</p>
  
 
  
  <p style="margin-bottom: 1em;">The music carries the weight of identity.<br>
  The prompts are shards of language, guiding the viewer toward deeper listening, closer looking, and questioning of self.</p>
  
  <p style="margin-bottom: 1em;">Meaning is assembled, not given.<br>
  Connection is felt, not consumed.</p>
  
  <p style="margin-bottom: 1em;">This is not a portfolio.<br>
  It is record and inquiry.<br>
  It is resistance.<br>
  It is stance.</p>
  
  <p style="margin-bottom: 0;">I am James Tobin.</p>
`;
Object.assign(manifestoText.style, {
  fontSize: "0.95rem",
  lineHeight: "1.7",
  color: "#f2f2f2",
  marginBottom: "40px",
  paddingBottom: "30px",
  borderBottom: "1px solid rgba(196, 0, 47, 0.3)",
  textAlign: "left",
  maxWidth: "700px",
  margin: "0 auto 40px"
});

const navGrid = document.createElement('div');
Object.assign(navGrid.style, {
  display: "grid",
  gridTemplateColumns: "repeat(auto-fill, minmax(250px, 1fr))",
  gap: "20px",
  marginBottom: "30px"
});

messages.forEach((msg, i) => {
  const card = document.createElement('div');
  Object.assign(card.style, {
    backgroundColor: "rgba(255, 255, 255, 0.1)",
    padding: "20px",
    borderRadius: "8px",
    cursor: "pointer",
    transition: "all 0.3s ease",
    border: "2px solid transparent"
  });
  
  card.addEventListener('mouseenter', () => {
    card.style.backgroundColor = "rgba(196, 0, 47, 0.2)";
    card.style.borderColor = "#c4002f";
    card.style.transform = "translateY(-4px)";
  });
  
  card.addEventListener('mouseleave', () => {
    card.style.backgroundColor = "rgba(255, 255, 255, 0.1)";
    card.style.borderColor = "transparent";
    card.style.transform = "translateY(0)";
  });
  
  const slideNum = document.createElement('div');
 slideNum.textContent = i === 0 ? "1." : `${i + 1}`;  Object.assign(slideNum.style, {
    fontSize: "0.9rem",
    color: "#c4002f",
    fontWeight: "600",
    marginBottom: "10px",
    textTransform: "uppercase",
    letterSpacing: "0.05em"
  });
  
  
 const caption = document.createElement('div');

// Override the first slide caption
caption.textContent = i === 0 ? "Introduction" : (msg.caption || hints[i] || "Tap to explore");

Object.assign(caption.style, {
  fontSize: "0.95rem",
  lineHeight: "1.5",
  color: "#f2f2f2"
});
  
  card.appendChild(slideNum);
  card.appendChild(caption);
  
 card.addEventListener('click', () => {
Â  Â  navOverlay.style.display = "none";
Â  Â Â 
Â  Â  // 1. Pause any playing audio and clear track end listeners
Â  Â  sharedAudio.pause();
Â  Â  sharedAudio.currentTime = 0;
Â  Â  onTrackEnded = null;
Â  Â Â 
Â  Â Â 
Â  Â Â // NEW: Remove mouseover/touch listeners to prevent accidental hint covering
    if (currentShowCover) {
        aperture.removeEventListener("mouseenter", currentShowCover);
        aperture.removeEventListener("touchstart", currentShowCover);
    }
    if (currentHideCover) {
        aperture.removeEventListener("mouseleave", currentHideCover);
        aperture.removeEventListener("touchend", currentHideCover);
    }
    
    currentShowCover = null;
    currentHideCover = null;
    
Â  Â  // 2. Set the index to the selected slide
Â  Â  idx = i;
Â  Â Â 
Â  Â  // 3. Reset the visual state to display the hint
Â  Â  stopStarfield();
Â  Â  james.style.display = "none";
Â  Â  coverImage.style.display = "none";
Â  Â  centerText.classList.remove("show");
Â  Â  barrel.classList.remove("playing");
Â  Â  barrel.classList.add("pulse"); // Re-enable pulse animation
Â  Â  spinHint.classList.remove("hidden");
Â  Â Â 
Â  Â  // 4. Display the hint for the selected slide
Â  Â  spinHint.textContent = hints[idx] || "Tap (â€º)";
Â  Â Â 
Â  Â  // 5. Update the progress bar and mark as ready for the second stage click
Â  Â  progressBar.style.width = `${((idx + 1) / messages.length) * 100}%`;
Â  Â  progressInput.value = idx;
Â  Â  firstClickShown = true;
});

  navGrid.appendChild(card);
});

const closeBtn = document.createElement('button');
closeBtn.textContent = "Close";
Object.assign(closeBtn.style, {
  display: "block",
  margin: "30px auto 0",
  padding: "12px 40px",
  backgroundColor: "#c4002f",
  color: "#fff",
  border: "none",
  borderRadius: "6px",
  fontSize: "1rem",
  fontWeight: "600",
  cursor: "pointer",
  textTransform: "uppercase",
  letterSpacing: "0.05em",
  transition: "all 0.3s ease"
});

closeBtn.addEventListener('mouseenter', () => {
  closeBtn.style.backgroundColor = "#ff0040";
  closeBtn.style.transform = "scale(1.05)";
});

closeBtn.addEventListener('mouseleave', () => {
  closeBtn.style.backgroundColor = "#c4002f";
  closeBtn.style.transform = "scale(1)";
});

closeBtn.addEventListener('click', () => {
  navOverlay.style.display = "none";
});

navContent.appendChild(navTitle);
navContent.appendChild(manifestoText);
navContent.appendChild(navGrid);
navContent.appendChild(closeBtn);
navOverlay.appendChild(navContent);
document.body.appendChild(navOverlay);

// Add button to open overlay
const openNavBtn = document.createElement('button');
openNavBtn.textContent = "â˜°";
Object.assign(openNavBtn.style, {
  position: "fixed",
  top: "20px",
  right: "20px",
  width: "50px",
  height: "50px",
  backgroundColor: "rgba(196, 0, 47, 0.9)",
  color: "#fff",
  border: "none",
  display: "none",
  borderRadius: "50%",
  fontSize: "1.5rem",
  cursor: "pointer",
  zIndex: "1001",
  transition: "all 0.3s ease",
  boxShadow: "0 4px 10px rgba(0, 0, 0, 0.3)"
});

openNavBtn.addEventListener('mouseenter', () => {
  openNavBtn.style.backgroundColor = "#ff0040";
  openNavBtn.style.transform = "scale(1.1)";
});

openNavBtn.addEventListener('mouseleave', () => {
  openNavBtn.style.backgroundColor = "rgba(196, 0, 47, 0.9)";
  openNavBtn.style.transform = "scale(1)";
});

openNavBtn.addEventListener('click', () => {
  navOverlay.style.display = "block";
});

document.body.appendChild(openNavBtn);


Object.assign(progressBarContainer.style, {
  position: "absolute",
  bottom: "20px",
  left: "20px",
  width: "calc(100% - 40px)",
  display: "flex",
  alignItems: "center",
  gap: "10px",
  zIndex: "1000"
});

progressLabel.textContent = "NAVIGATE";
Object.assign(progressLabel.style, {
  color: "#fff",
  fontSize: "14px",
  fontWeight: "600",
  textTransform: "uppercase",
  letterSpacing: "0.05em",
  minWidth: "80px",
  opacity: "0.9",
  flexShrink: "0",
  cursor: "pointer",
  transition: "color 0.3s ease"
});

progressLabel.addEventListener('mouseenter', () => {
  progressLabel.style.color = "#c4002f";
});

progressLabel.addEventListener('mouseleave', () => {
  progressLabel.style.color = "#fff";
});

progressLabel.addEventListener('click', () => {
  navOverlay.style.display = "block";
});

const progressBarInner = document.createElement('div');
Object.assign(progressBarInner.style, {
  position: "relative",
  flex: "1",
  height: "8px",
  backgroundColor: "rgba(255, 255, 255, 0.2)",
  borderRadius: "4px",
  overflow: "hidden"
});

Object.assign(progressBar.style, {
  height: "100%",
  backgroundColor: "white",
  width: "0%",
  pointerEvents: "none",
  transition: "width 0.2s ease"
});

progressInput.type = "range";
progressInput.min = "-1";
progressInput.max = String(messages.length - 1);
progressInput.value = "0";
Object.assign(progressInput.style, {
  position: "absolute",
  top: "0",
  left: "0",
  width: "100%",
  height: "100%",
  cursor: "pointer",
  opacity: "0",
  zIndex: "2"
});

progressBarInner.appendChild(progressBar);
progressBarInner.appendChild(progressInput);
progressBarContainer.appendChild(progressLabel);
progressBarContainer.appendChild(progressBarInner);
document.body.appendChild(progressBarContainer);

let currentShowCover = null;
let currentHideCover = null;

progressInput.addEventListener('input', (e) => {
  const newIdx = parseInt(e.target.value);
  
  
  
  sharedAudio.pause();
  sharedAudio.currentTime = 0;
  
  if (currentShowCover) {
    aperture.removeEventListener("mouseenter", currentShowCover);
    aperture.removeEventListener("touchstart", currentShowCover);
  }
  if (currentHideCover) {
    aperture.removeEventListener("mouseleave", currentHideCover);
    aperture.removeEventListener("touchend", currentHideCover);
  }
  currentShowCover = null;
  currentHideCover = null;
  
  idx = newIdx;
  stopStarfield();
  james.style.display = "none";
  coverImage.style.display = "none";
  centerText.classList.remove("show");
  barrel.classList.remove("playing");
  barrel.classList.add("pulse");
  spinHint.classList.remove("hidden");
  
    // Ensure user can navigate freely after using slider
  if (idx >= 0) {
    firstClickShown = true;
  }
  
  spinHint.textContent = hints[idx] || "Tap (â€º)";
  
  progressBar.style.width = `${((idx + 1) / messages.length) * 100}%`;
  progressInput.value = idx;
});

function resetToFirstSlide() {
  idx = -1;
  stopStarfield();
  james.style.display = "none";
  coverImage.style.display = "none";
  centerText.classList.remove("show");
  centerText.textContent = "";
  spinHint.textContent = "Tap | Touch";
  spinHint.classList.remove("hidden");
  barrel.classList.remove("playing");
  barrel.classList.add("pulse");
  
  sharedAudio.pause();
  sharedAudio.currentTime = 0;
  
  // NEW: Remove mouseover/touch listeners when resetting
    if (currentShowCover) {
        aperture.removeEventListener("mouseenter", currentShowCover);
        aperture.removeEventListener("touchstart", currentShowCover);
    }
    if (currentHideCover) {
        aperture.removeEventListener("mouseleave", currentHideCover);
        aperture.removeEventListener("touchend", currentHideCover);
    }
    currentShowCover = null;
    currentHideCover = null;
    
  centerText.removeEventListener("click", resetToFirstSlide);
  coverImage.classList.remove("cover-spin");
  progressBar.style.width = `${((idx + 1) / messages.length) * 100}%`;
  progressInput.value = -1;
}

function showMessage(i) {
  const m = messages[i];
  
  stopStarfield();
  james.style.display = "none";
  coverImage.style.display = "none";
  centerText.classList.remove("show");
  centerText.textContent = "";
  spinHint.classList.add("hidden");
  barrel.classList.remove("pulse");
  barrel.classList.add("playing");

  playThroughGain(m.music);
  
  const showCover = () => {
    if (m.cover) {
      coverImage.src = m.cover;
      coverImage.style.display = "block";
      coverImage.classList.add("cover-spin");
    }
    if (m.line) {
      centerText.textContent = m.line;
      centerText.classList.add("show");
    }
  };
  
  const hideCover = () => {
    coverImage.style.display = "none";
    coverImage.classList.remove("cover-spin");
    centerText.classList.remove("show");
  };
  
  if (currentShowCover) {
    aperture.removeEventListener("mouseenter", currentShowCover);
    aperture.removeEventListener("touchstart", currentShowCover);
  }
  if (currentHideCover) {
    aperture.removeEventListener("mouseleave", currentHideCover);
    aperture.removeEventListener("touchend", currentHideCover);
  }
  
  currentShowCover = showCover;
  currentHideCover = hideCover;
  
  if (i !== messages.length - 1) {
    startStarfield();
    
    aperture.addEventListener("mouseenter", showCover);
    aperture.addEventListener("mouseleave", hideCover);
    aperture.addEventListener("touchstart", showCover);
    aperture.addEventListener("touchend", hideCover);
  }

 onTrackEnded = () => {
  // If we just finished the final slide, reset the whole experience.
  if (idx === messages.length - 1) {
    resetToFirstSlide();
    return;
  }

  // --- START FIX: Advance to the NEXT slide's hint state ---

  // 1. Increment the index to point to the NEXT slide (N+1).
  idx++; 

  // 2. Remove click/hover listeners added for the just-finished slide.
  // (This is already correctly implemented below)
  
  // 3. Reset visual state to show the hint for the new index.
  stopStarfield();
  coverImage.style.display = "none";
  coverImage.classList.remove("cover-spin");
  centerText.classList.remove("show");
  barrel.classList.remove("playing");
  
  // 4. Show the hint for the NEW (N+1) index.
  barrel.classList.add("pulse"); // Re-enable pulse animation
  spinHint.classList.remove("hidden");
  spinHint.textContent = hints[idx] || "Tap (â€º)"; // Use the new idx
  
  // 5. Update the progress bar to show the new index hint is ready.
  progressBar.style.width = `${((idx + 1) / messages.length) * 100}%`;
  progressInput.value = idx;

  // --- END FIX ---


  // Cleanup listeners (already correct in your original code)
  aperture.removeEventListener("mouseenter", showCover);
  aperture.removeEventListener("mouseleave", hideCover);
  aperture.removeEventListener("touchstart", showCover);
  aperture.removeEventListener("touchend", hideCover);

  currentShowCover = null;
  currentHideCover = null;
};

  if (i === messages.length - 1) {
    stopStarfield();
    coverImage.style.display = "none";
    james.style.display = "block";

    setTimeout(() => {
      centerText.textContent = "I'm James Tobin.";
      centerText.classList.add("show");
      centerText.addEventListener("click", resetToFirstSlide, { once: true });
    }, 2000);
  }

  progressBar.style.width = `${((i + 1) / messages.length) * 100}%`;
  progressInput.value = i;
}

barrel.addEventListener("click", (e) => {
Â  if (dragging || draggingPosition) return;
Â  
Â  audioCtx.resume();
Â Â 
Â  // State 1: Barrel is NOT playing, and we are showing a hint (index is set, either from nav or slide end).
Â  if (!barrel.classList.contains("playing") && idx >= 0) {
Â  Â  // This is the **second click/tap**: PLAY the currently set slide (idx).
Â  Â  showMessage(idx);
Â  Â  return; // Track is now playing, so exit.
Â  }

Â  // State 2: Initial click (if they didn't use the navigation and idx is -1).
Â  if (idx === -1) {
Â  Â  // First tap: Show the hint for the first slide (idx 0).
Â  Â  idx = 0;
Â  Â  spinHint.textContent = hints[idx] || "Play Audio? (â€º)";
Â  Â  progressBar.style.width = `${((idx + 1) / messages.length) * 100}%`;
Â  Â  progressInput.value = idx;
Â  Â  firstClickShown = true;
Â  Â  return;
Â  }
Â Â 
Â  // State 3: User clicks while a slide is playing (do nothing or wait for track to end).
Â  if (barrel.classList.contains("playing")) return;
Â Â 
Â  // State 4 (Sequential Flow): Advance to the next hint.
Â  if (idx < messages.length - 1) {
Â  Â  idx++;
Â  Â  // Reset state to show the hint for the newly incremented index
Â  Â  stopStarfield();
Â  Â  james.style.display = "none";
Â  Â  coverImage.style.display = "none";
Â  Â  centerText.classList.remove("show");
Â  Â  barrel.classList.remove("playing");
Â  Â  barrel.classList.add("pulse");
Â  Â  spinHint.classList.remove("hidden");
Â  Â  spinHint.textContent = hints[idx] || "Tap (â€º)";
Â  Â  progressBar.style.width = `${((idx + 1) / messages.length) * 100}%`;
Â  Â  progressInput.value = idx;
Â  } else if (idx === messages.length - 1) {
Â  Â  // Handle loop/reset if on the last slide hint
Â  Â  resetToFirstSlide();
Â  }
});


function getVolume(e) {
  const rect = barrel.getBoundingClientRect();
  const cy = rect.top + rect.height / 2;
  const radius = rect.height / 2;
  const y = e.touches ? e.touches[0].clientY : e.clientY;
  const v = (cy - y + radius) / (2 * radius);
  return Math.min(Math.max(v, 0), 1);
}

let dragTimeout;

barrel.addEventListener("mousedown", (e) => {
  const startTime = Date.now();
  const startX = e.clientX;
  const startY = e.clientY;
  
  const checkDrag = () => {
    const timeDiff = Date.now() - startTime;
    const distance = Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2));
    
    if (timeDiff > 150 && barrel.classList.contains("playing")) {
      dragging = true;
      volumeIndicator.classList.add("show");
    } else if (distance > 10) {
      draggingPosition = true;
      barrel.classList.add("dragging-position");
      dragStartX = e.clientX - barrelX;
      dragStartY = e.clientY - barrelY;
    }
  };
  
  dragTimeout = setTimeout(checkDrag, 150);
  
  const moveHandler = (moveE) => {
    const distance = Math.sqrt(Math.pow(moveE.clientX - startX, 2) + Math.pow(moveE.clientY - startY, 2));
    if (distance > 10) {
      clearTimeout(dragTimeout);
      draggingPosition = true;
      barrel.classList.add("dragging-position");
      dragStartX = moveE.clientX - barrelX;
      dragStartY = moveE.clientY - barrelY;
      window.removeEventListener("mousemove", moveHandler);
    }
  };
  
  window.addEventListener("mousemove", moveHandler);
  setTimeout(() => window.removeEventListener("mousemove", moveHandler), 200);
});

barrel.addEventListener("touchstart", (e) => {
  const startTime = Date.now();
  const touch = e.touches[0];
  const startX = touch.clientX;
  const startY = touch.clientY;
  
  const checkDrag = () => {
    const timeDiff = Date.now() - startTime;
    
    if (timeDiff > 150 && barrel.classList.contains("playing")) {
      dragging = true;
      volumeIndicator.classList.add("show");
    }
  };
  
  dragTimeout = setTimeout(checkDrag, 150);
  
  const moveHandler = (moveE) => {
    const touch = moveE.touches[0];
    const distance = Math.sqrt(Math.pow(touch.clientX - startX, 2) + Math.pow(touch.clientY - startY, 2));
    if (distance > 10) {
      clearTimeout(dragTimeout);
      draggingPosition = true;
      barrel.classList.add("dragging-position");
      dragStartX = touch.clientX - barrelX;
      dragStartY = touch.clientY - barrelY;
      window.removeEventListener("touchmove", moveHandler);
    }
  };
  
  window.addEventListener("touchmove", moveHandler, { passive: true });
  setTimeout(() => window.removeEventListener("touchmove", moveHandler), 200);
}, { passive: true });

window.addEventListener("mousemove", (e) => {
  if (draggingPosition) {
    barrelX = e.clientX - dragStartX;
    barrelY = e.clientY - dragStartY;
    barrel.style.left = `${barrelX}px`;
    barrel.style.top = `${barrelY}px`;
    } else if (dragging) {
    const v = getVolume(e);
    gainNode.gain.value = v;
    
    // Update mute state
    if (v === 0) {
      isMuted = true;
      volumeLabel.textContent = "ðŸ”‡ VOLUME";
      volumeIndicator.textContent = "Muted";
    } else {
      isMuted = false;
      previousVolume = v;
      volumeLabel.textContent = "ðŸ”Š VOLUME";
      volumeIndicator.textContent = `Volume: ${Math.round(v * 100)}%`;
    }
    
    volumeSlider.value = Math.round(v * 100);
    volumeFill.style.width = `${Math.round(v * 100)}%`;
    
    barrel.classList.add("dragging-volume");
    outerRing.classList.add("active");
  
  }
});

window.addEventListener("touchmove", (e) => {
  if (draggingPosition) {
    e.preventDefault();
    const touch = e.touches[0];
    barrelX = touch.clientX - dragStartX;
    barrelY = touch.clientY - dragStartY;
    barrel.style.left = `${barrelX}px`;
    barrel.style.top = `${barrelY}px`;
  } else if (dragging) {
    e.preventDefault();
    const v = getVolume(e);
    gainNode.gain.value = v;
    volumeIndicator.textContent = `Volume: ${Math.round(v * 100)}%`;
    
    volumeSlider.value = Math.round(v * 100);
    volumeFill.style.width = `${Math.round(v * 100)}%`;
    
    barrel.classList.add("dragging-volume");
    outerRing.classList.add("active");
  }
}, { passive: false });

function stopDrag() {
  clearTimeout(dragTimeout);
  
  if (dragging) {
    // Remove classes immediately for visual feedback
    barrel.classList.remove("dragging-volume");
    outerRing.classList.remove("active");
    
    // Reset dragging state after a short delay to prevent click events
    setTimeout(() => { 
      dragging = false; 
    }, 100);
  }
  
  if (draggingPosition) {
    manuallyPositioned = true;
    barrel.classList.remove("dragging-position");
    setTimeout(() => { 
      draggingPosition = false; 
    }, 100);
  }
  
  // Hide volume indicator with slight delay for better UX
  setTimeout(() => {
    volumeIndicator.classList.remove("show");
  }, 500);
}

window.addEventListener("mouseup", stopDrag);
window.addEventListener("touchend", stopDrag);

function scaleUI() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  
  const barrelRect = barrel.getBoundingClientRect();
  const barrelSize = barrelRect.width;
  
  if (!manuallyPositioned) {
    barrelX = (vw - barrelSize) / 2;
    barrelY = (vh - barrelSize) / 2;
  }
  
  barrel.style.left = `${barrelX}px`;
  barrel.style.top = `${barrelY}px`;
  
  if (starCanvas.style.display === "block") {
    resizeCanvas();
  }
}

let resizeTimeout;
function handleResize() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(scaleUI, 100);
}

window.addEventListener('load', scaleUI);
window.addEventListener('resize', handleResize);
window.addEventListener('orientationchange', () => {
  setTimeout(scaleUI, 300);
});
</script>

<script>
(function() {
  const dynamicStyle = document.createElement('style');
  dynamicStyle.setAttribute('id', 'dynamic-highres-style');
  document.head.appendChild(dynamicStyle);

  function applyHighResSizing() {
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const dpr = window.devicePixelRatio || 1;

    // Detect orientation
    const isPortrait = vh > vw;

    // Base barrel size: use width in portrait, vmin in landscape
    let barrelSize = isPortrait ? 0.70 * vw : 0.70 * Math.min(vw, vh);

    // Gentle boost for large screens
    if (vw >= 2560) barrelSize *= 1.05;
    if (vw >= 3840) barrelSize *= 1.15;
    if (vw >= 5120) barrelSize *= 1.25;
    if (dpr >= 2)   barrelSize *= 1.05;

    // Small device shrink
    if (vw <= 480) barrelSize *= 0.85;

    // Clamp between 200px (phones) and 1200px (big monitors)
    barrelSize = Math.max(200, Math.min(barrelSize, 1200));

    // Font scaling
    let rootFont = 16;
    if (vw >= 2560) rootFont = 17;
    if (vw >= 3840) rootFont = 19;
    if (vw >= 5120) rootFont = 21;
    if (dpr >= 2)   rootFont += 1;
    if (vw <= 480)  rootFont = 14;
    rootFont = Math.min(rootFont, 22);

    // Text sizes
    const hintFontPx   = vw <= 480 ? 12 : Math.round((2.0 / 100) * (isPortrait ? vw : Math.min(vw, vh)));
    const centerFontPx = vw <= 480 ? 14 : Math.round((2.6 / 100) * (isPortrait ? vw : Math.min(vw, vh)));
    const volFontPx    = Math.round(rootFont * 1.3);

    dynamicStyle.textContent = `
      html { font-size: ${rootFont}px; }
      .barrel {
        width: ${barrelSize}px !important;
        height: ${barrelSize}px !important;
        max-width: none !important;
        max-height: none !important;
      }
      .aperture { width: 60% !important; height: 60% !important; }
      .spin-hint { font-size: ${hintFontPx}px !important; }
      .center-text { font-size: ${centerFontPx}px !important; }
      .volume-indicator { font-size: ${volFontPx}px !important; }
      body > div[style*="width: calc(100% - 40px)"][style*="display: flex"] div[style*="height: 8px"] {
        height: ${vw <= 480 ? 6 : 10}px !important;
      }
    `;

    // Re-center barrel
    const barrel = document.getElementById('barrel');
    if (barrel) {
      const rect = barrel.getBoundingClientRect();
      barrel.style.left = `${(vw - rect.width) / 2}px`;
      barrel.style.top  = `${(vh - rect.height) / 2}px`;
    }

    // Resize starfield canvas if visible
    const starCanvas = document.getElementById('starfield');
    const aperture = document.getElementById('aperture');
    if (starCanvas && aperture && starCanvas.style.display === 'block') {
      starCanvas.width  = aperture.offsetWidth;
      starCanvas.height = aperture.offsetHeight;
    }
  }

  window.addEventListener('load', applyHighResSizing);
  window.addEventListener('resize', applyHighResSizing);
  window.addEventListener('orientationchange', () => setTimeout(applyHighResSizing, 200));
})();
</script>

  <script>
   // --- PASTE THIS CODE AT THE END OF YOUR MAIN SCRIPT BLOCK ---

// This function runs automatically once the page is fully structured (or 'loaded')
function openNavOverlayOnLoad() {
    // Since navOverlay is a global const inside this script, we can reference it directly.
    // If we were in a separate script, we'd use document.getElementById('navOverlay').

    // 1. Open the overlay
    navOverlay.style.display = "block";
    
    // 2. Hide the main navigation button (since the menu is now open)
    // NOTE: openNavBtn is declared later, so we must find it by ID or wait for 'load'.
    const openNavBtn = document.getElementById('openNavBtn');
    if (openNavBtn) {
        openNavBtn.style.display = "hidden";
    }
}

// Ensure the ID is set for external reference later:
navOverlay.id = "navOverlay";
openNavBtn.id = "openNavBtn"; // Make sure you add this ID to the button too!

// We use 'load' to be safe, ensuring all images and elements are ready.
window.addEventListener('load', openNavOverlayOnLoad);

// You should also update your close button logic to show the openNavBtn again
closeBtn.addEventListener('click', () => {
    navOverlay.style.display = "none";
    openNavBtn.style.display = "block"; // <-- Ensure this is here
});

// --- END OF CODE TO PASTE ---
</script>

</body>
</html>
